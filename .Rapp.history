res1 <- do.call(FUN, extra.args, envir = parent.frame())
FUN
names(FUN)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
FUN = ttestBF
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
res1 <- do.call(FUN, extra.args, envir = parent.frame())
ttestBF(formula=extra.args$formula, data=extra.args$data)
ttestBF(formula=extra.args$formula, data=extra.args$data)
extra.args$data
extra.args$formula
options(error=recover)
ttestBF(formula=extra.args$formula, data=extra.args$data)
options(error=NULL)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
switch(BFtype,#
			BFoneSample = {extra.args$x <- dat[1:ns[i], ]},#
			BFindepSample = {#
				extra.args$formula <- as.formula(formula)				#
				# sample min.n from each group#
				extra.args$data <- dat %>% group_by(group) %>% slice(1:ns[i]) %>% ungroup()#
			}#
		)#
		res1 <- do.call(FUN, extra.args, envir = parent.frame())
str(extra.args$data)
str(extra.args$formula)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
dat %>% group_by(group) %>% slice(1:ns[i]) %>% ungroup() %>% as.data.frame()
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
extra.args$data <- dat %>% group_by(group) %>% slice(1:ns[i]) %>% ungroup() %>% as.data.frame()
str(extra.args$data)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
res1 <- do.call(FUN, extra.args, envir = parent.frame())
res1
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
dat <- BFobject@data#
	formula <- BFobject@numerator[[1]]@identifier$formula#
	BFtype <- class(BFobject@numerator[[1]])#
	print(BFtype)#
	FUN <- NULL#
	extra.args <- NULL#
	switch(BFtype,#
		BFoneSample = {#
			FUN = ttestBF#
			extra.args = list(#
				paired = FALSE, #
				rscale = BFobject@numerator[[1]]@prior$rscale, #
				mu = BFobject@numerator[[1]]@prior$mu)#
		},#
		BFindepSample = {#
			FUN = ttestBF#
			extra.args = list(#
				paired = FALSE, #
				rscale = BFobject@numerator[[1]]@prior$rscale)#
		}#
	)#
	if (is.null(FUN)) stop(paste0("BayesFactor object of type '", BFtype, "' not recognized (yet)."))#
	ns <- seq(min.n, nrow(dat), by=step)#
	pb <- txtProgressBar(min = 0, max = length(ns), style=3)#
	resSeq <- data.frame()#
	# TODO: Sample within each experimental group#
	for (i in 1:length(ns)) {#
		switch(BFtype,#
			BFoneSample = {extra.args$x <- dat[1:ns[i], ]},#
			BFindepSample = {#
				extra.args$formula <- as.formula(formula)				#
				# sample min.n from each group#
				extra.args$data <- dat %>% group_by(group) %>% slice(1:ns[i]) %>% ungroup() %>% as.data.frame()#
			}#
		)#
		res1 <- do.call(FUN, extra.args, envir = parent.frame())	#
		resSeq <- rbind(resSeq, data.frame(n=ns[i], BF=as.vector(res1)))#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)
seqRes
resSeq
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
dat %>% count(group)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
dat %>% count(group) %>% max()
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
counts = dat %>% count(group)#
			max.n = max(counts$n)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
max.n
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
dat <- BFobject@data#
	formula <- BFobject@numerator[[1]]@identifier$formula#
	BFtype <- class(BFobject@numerator[[1]])#
	print(BFtype)#
	FUN <- NULL#
	extra.args <- NULL#
	n.max <- NULL#
	switch(BFtype,#
		BFoneSample = {#
			FUN = ttestBF#
			max.n = nrow(dat)#
			extra.args = list(#
				paired = FALSE, #
				rscale = BFobject@numerator[[1]]@prior$rscale, #
				mu = BFobject@numerator[[1]]@prior$mu)#
		},#
		BFindepSample = {#
			FUN = ttestBF#
			counts = dat %>% count(group)#
			max.n = max(counts$n)#
			extra.args = list(#
				paired = FALSE, #
				rscale = BFobject@numerator[[1]]@prior$rscale)#
		}#
	)#
	if (is.null(FUN)) stop(paste0("BayesFactor object of type '", BFtype, "' not recognized (yet)."))#
	# at which n's should the BF be calculated?#
	ns <- seq(min.n, max.n, by=step)#
	if (tail(ns, 1) != max.n) ns <- c(ns, max.n)#
#
	pb <- txtProgressBar(min = 0, max = length(ns), style=3)#
	resSeq <- data.frame()#
	# TODO: Sample within each experimental group#
	for (i in 1:length(ns)) {#
		switch(BFtype,#
			BFoneSample = {extra.args$x <- dat[1:ns[i], ]},#
			BFindepSample = {#
				extra.args$formula <- as.formula(formula)				#
				# sample min.n from each group#
				extra.args$data <- dat %>% group_by(group) %>% slice(1:ns[i]) %>% ungroup() %>% as.data.frame()#
			}#
		)#
		res1 <- do.call(FUN, extra.args, envir = parent.frame())	#
		resSeq <- rbind(resSeq, data.frame(n=ns[i], BF=as.vector(res1)))#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)
resSeq
BFobject
str(BFobject)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
pb <- txtProgressBar(min = 0, max = length(ns), style=3)#
	resSeq <- data.frame()#
	# TODO: Sample within each experimental group#
	for (i in 1:length(ns)) {#
		switch(BFtype,#
			BFoneSample = {extra.args$x <- dat[1:ns[i], ]},#
			BFindepSample = {#
				extra.args$formula <- as.formula(formula)				#
				# sample min.n from each group#
				extra.args$data <- dat %>% group_by(group) %>% slice(1:ns[i]) %>% ungroup() %>% as.data.frame()#
			}#
		)#
		res1 <- do.call(FUN, extra.args, envir = parent.frame())	#
		resSeq <- rbind(resSeq, data.frame(#
			n  = ns[i], #
			BF = res1@bayesFactor$bf,#
			error = res1@bayesFactor$error#
		))#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)
resSeq
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras')
(ttest.2 <- ttestBF(x = rnorm(38), y = rnorm(35)+.8))#
(ttest.2b <- ttestBF(x = rnorm(38), y = rnorm(35)+.8, rscale=1))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
BFobject <- ttest.2b
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
dat <- BFobject@data#
	formula <- BFobject@numerator[[1]]@identifier$formula#
	BFtype <- class(BFobject@numerator[[1]])#
	print(BFtype)#
	FUN <- NULL#
	extra.args <- NULL#
	n.max <- NULL#
	switch(BFtype,#
		BFoneSample = {#
			FUN = ttestBF#
			max.n = nrow(dat)#
			extra.args = list(#
				paired = FALSE, #
				rscale = BFobject@numerator[[1]]@prior$rscale, #
				mu = BFobject@numerator[[1]]@prior$mu)#
		},#
		BFindepSample = {#
			FUN = ttestBF#
			counts = dat %>% count(group)#
			max.n = max(counts$n)#
			extra.args = list(#
				paired = FALSE, #
				rscale = BFobject@numerator[[1]]@prior$rscale)#
		}#
	)#
	if (is.null(FUN)) stop(paste0("BayesFactor object of type '", BFtype, "' not recognized (yet)."))#
	# at which n's should the BF be calculated?#
	ns <- seq(min.n, max.n, by=step)#
	if (tail(ns, 1) != max.n) ns <- c(ns, max.n)#
#
	pb <- txtProgressBar(min = 0, max = length(ns), style=3)#
	resSeq <- data.frame()#
	# TODO: Sample within each experimental group#
	for (i in 1:length(ns)) {#
		switch(BFtype,#
			BFoneSample = {extra.args$x <- dat[1:ns[i], ]},#
			BFindepSample = {#
				extra.args$formula <- as.formula(formula)				#
				# sample min.n from each group#
				extra.args$data <- dat %>% group_by(group) %>% slice(1:ns[i]) %>% ungroup() %>% as.data.frame()#
			}#
		)#
		res1 <- do.call(FUN, extra.args, envir = parent.frame())	#
		resSeq <- rbind(resSeq, data.frame(#
			n  = ns[i], #
			BF = res1@bayesFactor$bf,#
			error = res1@bayesFactor$error#
		))#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)
ttest2b
ttest.2b
resSeq
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
BFobject <- ttest.2b
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
dat <- BFobject@data#
	formula <- BFobject@numerator[[1]]@identifier$formula#
	BFtype <- class(BFobject@numerator[[1]])#
	print(BFtype)#
	FUN <- NULL#
	extra.args <- NULL#
	n.max <- NULL#
	switch(BFtype,#
		BFoneSample = {#
			FUN = ttestBF#
			max.n = nrow(dat)#
			extra.args = list(#
				paired = FALSE, #
				rscale = BFobject@numerator[[1]]@prior$rscale, #
				mu = BFobject@numerator[[1]]@prior$mu)#
		},#
		BFindepSample = {#
			FUN = ttestBF#
			counts = dat %>% count(group)#
			max.n = max(counts$n)#
			extra.args = list(#
				paired = FALSE, #
				rscale = BFobject@numerator[[1]]@prior$rscale)#
		}#
	)#
	if (is.null(FUN)) stop(paste0("BayesFactor object of type '", BFtype, "' not recognized (yet)."))
exrta.args
extra.args
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
max.n
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
ns <- seq(min.n, max.n, by=step)#
	if (tail(ns, 1) != max.n) ns <- c(ns, max.n)#
#
	pb <- txtProgressBar(min = 0, max = length(ns), style=3)#
	resSeq <- data.frame()
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
for (i in 1:length(ns)) {#
		switch(BFtype,#
			BFoneSample = {extra.args$x <- dat[1:ns[i], ]},#
			BFindepSample = {#
				extra.args$formula <- as.formula(formula)				#
				# sample min.n from each group#
				extra.args$data <- dat %>% group_by(group) %>% slice(1:ns[i]) %>% ungroup() %>% as.data.frame()#
			}#
		)#
		res1 <- do.call(FUN, extra.args, envir = parent.frame())	#
		resSeq <- rbind(resSeq, data.frame(#
			n  = ns[i], #
			BF = res1@bayesFactor$bf,#
			error = res1@bayesFactor$error#
		))#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)
resSeq
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
# at which n's should the BF be calculated?#
	ns <- seq(min.n, max.n, by=step)#
	if (tail(ns, 1) != max.n) ns <- c(ns, max.n)#
#
	pb <- txtProgressBar(min = 0, max = length(ns), style=3)#
	resSeq <- data.frame()#
	# TODO: Sample within each experimental group#
	for (i in 1:length(ns)) {#
		switch(BFtype,#
			BFoneSample = {extra.args$x <- dat[1:ns[i], ]},#
			BFindepSample = {#
				extra.args$formula <- as.formula(formula)				#
				# sample min.n from each group#
				extra.args$data <- dat %>% group_by(group) %>% slice(1:ns[i]) %>% ungroup() %>% as.data.frame()#
			}#
		)#
		res1 <- do.call(FUN, extra.args, envir = parent.frame())	#
		resSeq <- rbind(resSeq, data.frame(#
			n  = ns[i], #
			BF = exp(res1@bayesFactor$bf),#
			error = exp(res1@bayesFactor$error)#
		))#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)
resSeq
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
BFobject@seqBF <- resSeq#
	class(BFobject) <- "seqBF"
str(BFobject)
str(ttest.2)
getSlots(BFBayesFactor)
getSlots("BFBayesFactor")
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
setClass("BFBayesFactorSeq", contains = "BFBayesFactor")
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
RES <- new("BFBayesFactorSeq")
RES
str(RES)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
BFobject <- ttest.2
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
RES <- new("BFBayesFactorSeq")#
	RES <- BFobject
RES
str(RES)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
slots(BFobject)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
getSlots(BFobject)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
BFobject <- ttest.2
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
getSlots(BFobject)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
getSlot(BFobject)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
getSlots(BFobject)
BFobject
str(getSlots)
str(BFobject)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
slotnames(BFobject)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
slots(BFobject)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
getClass(BFobject)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
getSlots(BFBayesFactor)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
getSlots("BFBayesFactor")
BFobject[["numerator"]]
BFobject[["numerator"]]
s <- "numerator"
BFobject[s]
s <- "version"
BFobject[s]
BFobject
BFobject[[s]]
slot(BFobject, s)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
setClass("BFBayesFactorSeq", contains = "BFBayesFactor")#
#
	RES <- new("BFBayesFactorSeq")
str(RES)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
for (s in getSlots("BFBayesFactor")) {#
		slot(RES, s) <- slot(BFobject, s)#
	}
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
getSlots("BFBayesFactor")
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
for (s in names(getSlots("BFBayesFactor"))) {#
		slot(RES, s) <- slot(BFobject, s)#
	}
res
RES
str(RES)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
getSlots("BFBayesFactor")
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
setClass("BFBayesFactorSeq", slots = bayesFactorSeq, contains = "BFBayesFactor")#
#
	RES <- new("BFBayesFactorSeq")
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
setClass("BFBayesFactorSeq", slots = c(bayesFactorSeq="data.frame"), contains = "BFBayesFactor")
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
RES <- new("BFBayesFactorSeq")
str(RES)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
RES <- new("BFBayesFactorSeq")#
	# copy all existing slots into new object.#
	# FIXME: Can this be done more efficiently?#
	for (s in names(getSlots("BFBayesFactor"))) {#
		slot(RES, s) <- slot(BFobject, s)#
	}
RES
str(RES)
RES
as.vector(RES)
res
ttest.2
RES
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
RES@bayesFactorSeq <- resSeq
RES
str(RES)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
BFobject <- ttest.1
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
dat <- BFobject@data#
	formula <- BFobject@numerator[[1]]@identifier$formula#
	BFtype <- class(BFobject@numerator[[1]])#
	print(BFtype)#
	FUN <- NULL#
	extra.args <- NULL#
	n.max <- NULL#
	switch(BFtype,#
		BFoneSample = {#
			FUN = ttestBF#
			max.n = nrow(dat)#
			extra.args = list(#
				paired = FALSE, #
				rscale = BFobject@numerator[[1]]@prior$rscale, #
				mu = BFobject@numerator[[1]]@prior$mu)#
		},#
		BFindepSample = {#
			FUN = ttestBF#
			counts = dat %>% count(group)#
			max.n = max(counts$n)#
			extra.args = list(#
				paired = FALSE, #
				rscale = BFobject@numerator[[1]]@prior$rscale)#
		}#
		# extra.args$progress <- FALSE #
	)#
	if (is.null(FUN)) stop(paste0("BayesFactor object of type '", BFtype, "' not recognized (yet)."))#
	# at which n's should the BF be calculated?#
	ns <- seq(min.n, max.n, by=step)#
	if (tail(ns, 1) != max.n) ns <- c(ns, max.n)#
#
	pb <- txtProgressBar(min = 0, max = length(ns), style=3)#
	resSeq <- data.frame()#
	# TODO: Sample within each experimental group#
	for (i in 1:length(ns)) {#
		switch(BFtype,#
			BFoneSample = {extra.args$x <- dat[1:ns[i], ]},#
			BFindepSample = {#
				extra.args$formula <- as.formula(formula)				#
				# sample min.n from each group#
				extra.args$data <- dat %>% group_by(group) %>% slice(1:ns[i]) %>% ungroup() %>% as.data.frame()#
			}#
		)#
		res1 <- do.call(FUN, extra.args, envir = parent.frame())	#
		resSeq <- rbind(resSeq, data.frame(#
			n  = ns[i], #
			bf = res1@bayesFactor$bf,#
			error = res1@bayesFactor$error#
		))#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
	# define a new S4 class:#
	setClass("BFBayesFactorSeq", slots = c(bayesFactorSeq="data.frame"), contains = "BFBayesFactor")#
#
	RES <- new("BFBayesFactorSeq")#
	# copy all existing slots into new object.#
	# FIXME: Can this be done more efficiently?#
	for (s in names(getSlots("BFBayesFactor"))) {#
		slot(RES, s) <- slot(BFobject, s)#
	}#
#
	# add new sequential slot to results object#
	RES@bayesFactorSeq <- resSeq
ttest1
ttest.1
RES
RES@bayesFactorSeq
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
#' @export#
plot.BFBayesFactorSeq <- function(x, ...) {#
	seqBFplot(n = x@bayesFactorSeq$n, BF = x@bayesFactorSeq$BF, log.it=FALSE, ...)#
}
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
seqBF <- function(BFobject, min.n=10, step=1, ...) {#
#
	# BFobject <- ttest.1#
	# BFobject <- ttest.2#
	# BFobject <- ttest.2b#
	# BFobject <- ttest.p#
	# BFobject <- anova1#
	# BFobject <- lmBF1#
	dat <- BFobject@data#
	formula <- BFobject@numerator[[1]]@identifier$formula#
	BFtype <- class(BFobject@numerator[[1]])#
	print(BFtype)#
	FUN <- NULL#
	extra.args <- NULL#
	n.max <- NULL#
	switch(BFtype,#
		BFoneSample = {#
			FUN = ttestBF#
			max.n = nrow(dat)#
			extra.args = list(#
				paired = FALSE, #
				rscale = BFobject@numerator[[1]]@prior$rscale, #
				mu = BFobject@numerator[[1]]@prior$mu)#
		},#
		BFindepSample = {#
			FUN = ttestBF#
			counts = dat %>% count(group)#
			max.n = max(counts$n)#
			extra.args = list(#
				paired = FALSE, #
				rscale = BFobject@numerator[[1]]@prior$rscale)#
		}#
		# extra.args$progress <- FALSE #
	)#
	if (is.null(FUN)) stop(paste0("BayesFactor object of type '", BFtype, "' not recognized (yet)."))#
	# at which n's should the BF be calculated?#
	ns <- seq(min.n, max.n, by=step)#
	if (tail(ns, 1) != max.n) ns <- c(ns, max.n)#
#
	pb <- txtProgressBar(min = 0, max = length(ns), style=3)#
	resSeq <- data.frame()#
	# TODO: Sample within each experimental group#
	for (i in 1:length(ns)) {#
		switch(BFtype,#
			BFoneSample = {extra.args$x <- dat[1:ns[i], ]},#
			BFindepSample = {#
				extra.args$formula <- as.formula(formula)				#
				# sample min.n from each group#
				extra.args$data <- dat %>% group_by(group) %>% slice(1:ns[i]) %>% ungroup() %>% as.data.frame()#
			}#
		)#
		res1 <- do.call(FUN, extra.args, envir = parent.frame())	#
		resSeq <- rbind(resSeq, data.frame(#
			n  = ns[i], #
			bf = res1@bayesFactor$bf,#
			error = res1@bayesFactor$error#
		))#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
	# define a new S4 class:#
	setClass("BFBayesFactorSeq", slots = c(bayesFactorSeq="data.frame"), contains = "BFBayesFactor")#
#
	RES <- new("BFBayesFactorSeq")#
	# copy all existing slots into new object.#
	# FIXME: Can this be done more efficiently?#
	for (s in names(getSlots("BFBayesFactor"))) {#
		slot(RES, s) <- slot(BFobject, s)#
	}#
#
	# add new sequential slot to results object#
	RES@bayesFactorSeq <- resSeq#
	return(RES)#
}#
#' @export#
plot.BFBayesFactorSeq <- function(x, ...) {#
	seqBFplot(n = x@bayesFactorSeq$n, BF = x@bayesFactorSeq$BF, log.it=FALSE, ...)#
}
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
BF1 <- ttestBF(x = sleep$extra[sleep$group==1], y = sleep$extra[sleep$group==2], paired=TRUE)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
sBF1 <- seqBF(BF1, min.n=5)
sBF1
BF1
str(sBF1)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
plot(sBF1)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
#' Plot a sequence of Bayes factors#
#' #
#' This function creates a lineplot of a sequence of log Bayes factors. As a default, the function expects raw Bayes factors (i.e., non-logged Bayes factors). #
#' If you provide Bayes factors that are already logged (e.g., from the output of the \code{\link{ttest.tstat}} function), set \code{log.it} to \code{FALSE}.#
#' This function is in particular useful for plotting the trajectory of a sequential Bayes factor test#
#' @title Plot a Bayes factor object#
#' @param n A vector of numbers for the x axis#
#' @param BF A vector of Bayes factors (same length as x)#
#' @param xlab Label for x axis#
#' @param ylab Label for y axis#
#' @param main Main title#
#' @param log.it Should the Bayes factor in the \code{BF} parameter be logged?#
#' @param forH1 If \code{TRUE}, positive BFs mean evidence in favor of H1 ("H1 over H0" Bayes factor). This is the default in the Bayes factor package.#
#'#
#' @export#
#' @import ggplot2#
#' @import BayesFactor#
#' @importFrom grid unit#
#' @importFrom grid grid.draw#
#'#
#' @author Felix D. Schönbrodt (\email{felix@@nicebread.de})#
#' @examples#
#' ## Sleep data from t test example#
#' data(sleep)#
#' #
#' # Compute accumulating evidence from n1=5 participants to n2=10 participants#
#' BF <- c()#
#' for (i in 5:10) {#
#' 	BF0 <- ttestBF(#
#'		x = sleep$extra[sleep$group==1][1:i], #
#'		y = sleep$extra[sleep$group==2][1:i], paired=TRUE)#
#' 	BF <- c(BF, as.vector(BF0))#
#' }#
#' #
#' seqBFplot(5:10, BF)#
#
seqBFplot <- function(n, BF, xlab="n", ylab="log(BF)", main="", log.it=TRUE, forH1=TRUE) {#
	if (length(n) != length(BF)) stop("`n` and `BF` should have the same length")#
	if (length(n) < 1) stop("`n`and `BF` must habe length > 1")#
	if (log.it==TRUE) BF <- log(BF)#
	df <- data.frame(n, BF)#
	p1 <- ggplot(df, aes(x=n, y=BF)) + theme_bw() + ylab(ylab) + xlab(xlab)#
	# more than one data point? Line plot#
	if (length(n) > 1) {#
		p1 <- p1 + geom_line()#
		# custom labeler: find breaks with pretty numbers, and not more than 5#
		# find good divisor#
		steps <- c(2, 4, 5, 10, 15, 20, seq(30, 1000, by=10), seq(1100, 50000, by=100))#
		i <- 1#
		repeat {#
			mod <- (max(n)-min(n)+1) %/% steps[i]#
			if (mod <= 5) {break} else {i <- i+1}#
		}#
#
	    x.breaks <- seq(steps[i], max(n), by=steps[i])#
	    names(x.breaks) <- x.breaks#
	}#
	# One data point? Plot a single point#
	if (length(n) == 1) {#
		p1 <- p1 + geom_point()#
		x.breaks <- n#
	}#
	p1 <- p1 + scale_x_continuous(breaks=x.breaks)#
	# All the annotation stuff ...#
	p1 <- p1 + geom_hline(yintercept=c(c(-log(c(100, 30, 10, 3)), log(c(3, 10, 30, 100)))), linetype="dotted", color="darkgrey")#
	p1 <- p1 + geom_hline(yintercept=log(1), linetype="dashed", color="grey20")#
#
	p1 <- p1 + annotate("text", x=Inf, y=-5.15, label=paste0("~~Extreme~H[", ifelse(forH1==TRUE,0,1), "]"), #
		hjust=0, vjust=.5, size=3.2, color="black", parse=TRUE)#
	p1 <- p1 + annotate("text", x=Inf, y=-4.00, label=paste0("~~Very~strong~H[", ifelse(forH1==TRUE,0,1), "]"), #
		hjust=0, vjust=.5, size=3.2, color="black", parse=TRUE)#
	p1 <- p1 + annotate("text", x=Inf, y=-2.85, label=paste0("~~Strong~H[", ifelse(forH1==TRUE,0,1), "]"), #
		hjust=0, vjust=.5, size=3.2, color="black", parse=TRUE)#
	p1 <- p1 + annotate("text", x=Inf, y=-1.7 , label=paste0("~~Moderate~H[", ifelse(forH1==TRUE,0,1), "]"), #
		hjust=0, vjust=.5, size=3.2, color="black", parse=TRUE)#
	p1 <- p1 + annotate("text", x=Inf, y=-.55 , label=paste0("~~Anectodal~H[", ifelse(forH1==TRUE,0,1), "]"), #
		hjust=0, vjust=.5, size=3.2, color="black", parse=TRUE)#
#
	p1 <- p1 + annotate("text", x=Inf, y=5.15, label=paste0("~~Extreme~H[", ifelse(forH1==TRUE,1,0), "]"), #
		hjust=0, vjust=.5, size=3.2, color="black", parse=TRUE)#
	p1 <- p1 + annotate("text", x=Inf, y=4.00, label=paste0("~~Very~strong~H[", ifelse(forH1==TRUE,1,0), "]"), #
		hjust=0, vjust=.5, size=3.2, color="black", parse=TRUE)#
	p1 <- p1 + annotate("text", x=Inf, y=2.86 , label=paste0("~~Strong~H[", ifelse(forH1==TRUE,1,0), "]"), #
		hjust=0, vjust=.5, size=3.2, color="black", parse=TRUE)#
	p1 <- p1 + annotate("text", x=Inf, y=1.7  , label=paste0("~~Moderate~H[", ifelse(forH1==TRUE,1,0), "]"), #
		hjust=0, vjust=.5, size=3.2, color="black", parse=TRUE)#
	p1 <- p1 + annotate("text", x=Inf, y=.55  , label=paste0("~~Anectodal~H[", ifelse(forH1==TRUE,1,0), "]"), #
		hjust=0, vjust=.5, vjust=.5, size=3.2, color="black", parse=TRUE)#
#
	# set scale ticks#
	p1 <- p1 + scale_y_continuous(breaks=c(c(-log(c(100, 30, 10, 3)), 0, log(c(3, 10, 30, 100)))), labels=c("-log(100)", "-log(30)", "-log(10)", "-log(3)", "log(1)", "log(3)", "log(10)", "log(30)", "log(100)"))#
	if (main != "") p1 <- p1 + ggtitle(main)#
#
	p1 <- p1 + theme(plot.margin = grid::unit(c(1,5,1,1), "lines"))#
#
	# TODO: The annotation only works with this work-around; but now no ggplot-object is returned (which would be nice for users, to add their own themes, e.g.)#
	# Code to override clipping, from http://stackoverflow.com/questions/10014187/displaying-text-below-the-plot-generated-by-ggplot2 #
	gt <- ggplot_gtable(ggplot_build(p1))#
	gt$layout$clip[gt$layout$name == "panel"] <- "off"#
	grid::grid.draw(gt)#
}
plot(sBF1)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
#' Plot a sequence of Bayes factors#
#' #
#' This function creates a lineplot of a sequence of log Bayes factors. As a default, the function expects raw Bayes factors (i.e., non-logged Bayes factors). #
#' If you provide Bayes factors that are already logged (e.g., from the output of the \code{\link{ttest.tstat}} function), set \code{log.it} to \code{FALSE}.#
#' This function is in particular useful for plotting the trajectory of a sequential Bayes factor test#
#' @title Plot a Bayes factor object#
#' @param n A vector of numbers for the x axis#
#' @param bf A vector of Bayes factors (same length as x)#
#' @param xlab Label for x axis#
#' @param ylab Label for y axis#
#' @param main Main title#
#' @param log.it Should the Bayes factor in the \code{bf} parameter be logged?#
#' @param forH1 If \code{TRUE}, positive bfs mean evidence in favor of H1 ("H1 over H0" Bayes factor). This is the default in the Bayes factor package.#
#'#
#' @export#
#' @import ggplot2#
#' @import BayesFactor#
#' @importFrom grid unit#
#' @importFrom grid grid.draw#
#'#
#' @author Felix D. Schönbrodt (\email{felix@@nicebread.de})#
#' @examples#
#' ## Sleep data from t test example#
#' data(sleep)#
#' #
#' # Compute accumulating evidence from n1=5 participants to n2=10 participants#
#' bf <- c()#
#' for (i in 5:10) {#
#' 	bf0 <- ttestbf(#
#'		x = sleep$extra[sleep$group==1][1:i], #
#'		y = sleep$extra[sleep$group==2][1:i], paired=TRUE)#
#' 	bf <- c(bf, as.vector(bf0))#
#' }#
#' #
#' seqBFplot(5:10, bf)#
#
seqBFplot <- function(n, bf, xlab="n", ylab="log(bf)", main="", log.it=TRUE, forH1=TRUE) {#
	if (length(n) != length(bf)) stop("`n` and `bf` should have the same length")#
	if (length(n) < 1) stop("`n`and `bf` must habe length > 1")#
	if (log.it==TRUE) bf <- log(bf)#
	df <- data.frame(n, bf)#
	p1 <- ggplot(df, aes(x=n, y=bf)) + theme_bw() + ylab(ylab) + xlab(xlab)#
	# more than one data point? Line plot#
	if (length(n) > 1) {#
		p1 <- p1 + geom_line()#
		# custom labeler: find breaks with pretty numbers, and not more than 5#
		# find good divisor#
		steps <- c(2, 4, 5, 10, 15, 20, seq(30, 1000, by=10), seq(1100, 50000, by=100))#
		i <- 1#
		repeat {#
			mod <- (max(n)-min(n)+1) %/% steps[i]#
			if (mod <= 5) {break} else {i <- i+1}#
		}#
#
	    x.breaks <- seq(steps[i], max(n), by=steps[i])#
	    names(x.breaks) <- x.breaks#
	}#
	# One data point? Plot a single point#
	if (length(n) == 1) {#
		p1 <- p1 + geom_point()#
		x.breaks <- n#
	}#
	p1 <- p1 + scale_x_continuous(breaks=x.breaks)#
	# All the annotation stuff ...#
	p1 <- p1 + geom_hline(yintercept=c(c(-log(c(100, 30, 10, 3)), log(c(3, 10, 30, 100)))), linetype="dotted", color="darkgrey")#
	p1 <- p1 + geom_hline(yintercept=log(1), linetype="dashed", color="grey20")#
#
	p1 <- p1 + annotate("text", x=Inf, y=-5.15, label=paste0("~~Extreme~H[", ifelse(forH1==TRUE,0,1), "]"), #
		hjust=0, vjust=.5, size=3.2, color="black", parse=TRUE)#
	p1 <- p1 + annotate("text", x=Inf, y=-4.00, label=paste0("~~Very~strong~H[", ifelse(forH1==TRUE,0,1), "]"), #
		hjust=0, vjust=.5, size=3.2, color="black", parse=TRUE)#
	p1 <- p1 + annotate("text", x=Inf, y=-2.85, label=paste0("~~Strong~H[", ifelse(forH1==TRUE,0,1), "]"), #
		hjust=0, vjust=.5, size=3.2, color="black", parse=TRUE)#
	p1 <- p1 + annotate("text", x=Inf, y=-1.7 , label=paste0("~~Moderate~H[", ifelse(forH1==TRUE,0,1), "]"), #
		hjust=0, vjust=.5, size=3.2, color="black", parse=TRUE)#
	p1 <- p1 + annotate("text", x=Inf, y=-.55 , label=paste0("~~Anectodal~H[", ifelse(forH1==TRUE,0,1), "]"), #
		hjust=0, vjust=.5, size=3.2, color="black", parse=TRUE)#
#
	p1 <- p1 + annotate("text", x=Inf, y=5.15, label=paste0("~~Extreme~H[", ifelse(forH1==TRUE,1,0), "]"), #
		hjust=0, vjust=.5, size=3.2, color="black", parse=TRUE)#
	p1 <- p1 + annotate("text", x=Inf, y=4.00, label=paste0("~~Very~strong~H[", ifelse(forH1==TRUE,1,0), "]"), #
		hjust=0, vjust=.5, size=3.2, color="black", parse=TRUE)#
	p1 <- p1 + annotate("text", x=Inf, y=2.86 , label=paste0("~~Strong~H[", ifelse(forH1==TRUE,1,0), "]"), #
		hjust=0, vjust=.5, size=3.2, color="black", parse=TRUE)#
	p1 <- p1 + annotate("text", x=Inf, y=1.7  , label=paste0("~~Moderate~H[", ifelse(forH1==TRUE,1,0), "]"), #
		hjust=0, vjust=.5, size=3.2, color="black", parse=TRUE)#
	p1 <- p1 + annotate("text", x=Inf, y=.55  , label=paste0("~~Anectodal~H[", ifelse(forH1==TRUE,1,0), "]"), #
		hjust=0, vjust=.5, vjust=.5, size=3.2, color="black", parse=TRUE)#
#
	# set scale ticks#
	p1 <- p1 + scale_y_continuous(breaks=c(c(-log(c(100, 30, 10, 3)), 0, log(c(3, 10, 30, 100)))), labels=c("-log(100)", "-log(30)", "-log(10)", "-log(3)", "log(1)", "log(3)", "log(10)", "log(30)", "log(100)"))#
	if (main != "") p1 <- p1 + ggtitle(main)#
#
	p1 <- p1 + theme(plot.margin = grid::unit(c(1,5,1,1), "lines"))#
#
	# TODO: The annotation only works with this work-around; but now no ggplot-object is returned (which would be nice for users, to add their own themes, e.g.)#
	# Code to override clipping, from http://stackoverflow.com/questions/10014187/displaying-text-below-the-plot-generated-by-ggplot2 #
	gt <- ggplot_gtable(ggplot_build(p1))#
	gt$layout$clip[gt$layout$name == "panel"] <- "off"#
	grid::grid.draw(gt)#
}
str(sBF1)
x <- sBF1
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
x@bayesFactorSeq$n
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
x@bayesFactorSeq$bf
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
#' @export#
plot.BFBayesFactorSeq <- function(x, ...) {#
	seqBFplot(n = x@bayesFactorSeq$n, BF = x@bayesFactorSeq$bf, log.it=FALSE, ...)#
}#
BF1 <- ttestBF(x = sleep$extra[sleep$group==1], y = sleep$extra[sleep$group==2], paired=TRUE)#
sBF1 <- seqBF(BF1, min.n=5)#
plot(sBF1)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
#' @export#
plot.BFBayesFactorSeq <- function(x, ...) {#
	seqBFplot(n = x@bayesFactorSeq$n, bf = x@bayesFactorSeq$bf, log.it=FALSE, ...)#
}#
BF1 <- ttestBF(x = sleep$extra[sleep$group==1], y = sleep$extra[sleep$group==2], paired=TRUE)#
sBF1 <- seqBF(BF1, min.n=5)#
plot(sBF1)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras')
ttest.1.seq <- seqBF(ttest.1)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras')
plot(ttest.1.seq)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras')
ttest.2.seq <- seqBF(ttest.2)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras')
plot(ttest.2.seq)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras')
ttest.2b.seq <- seqBF(ttest.2b)#
plot(ttest.2b.seq)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras')
(anova1 <- anovaBF(extra ~ group + ID, data = sleep, whichRandom = "ID", progress=FALSE))
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
BFobject <- anova1
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras')
anova1.seq <- seqBF(anova1)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
#' Plot a sequence of Bayes factors#
#' #
#' This function creates a lineplot of a sequence of log Bayes factors. As a default, the function expects raw Bayes factors (i.e., non-logged Bayes factors). #
#' If you provide Bayes factors that are already logged (e.g., from the output of the ttest.tstat function), set \code{log.it} to \code{FALSE}.#
#' This function is in particular useful for plotting the trajectory of a sequential Bayes factor test#
#' @title Plot a Bayes factor object#
#' @param ... Parameters for the BayesFactor function defined in \code{FUN}. ALL parameters must be named.#
#' @param FUN String of the function of the BayesFactor package that should be applied, either "ttestBF", "lmBF", or "anovaBF"#
#' @param min.n Smallest number of participants for which the first BF should be computed. In a one-sample t test / paired t test, this is the overall sample size. In two-sample t tests and ANOVAs, this is the minimum size for each group.#
#' @param step Step size with which the number of participants is increased#
#' @author Felix Schönbrodt#
#
#' @export#
#' @import BayesFactor#
#' @importFrom dplyr#
#
#' @examples#
#' \dontrun{#
#' ## Sleep data from t test example#
#' data(sleep)#
#' #
#' # Compute accumulating evidence from n1=5 participants to n2=10 participants#
#' BF <- c()#
#' for (i in 5:10) {#
#' 	BF0 <- ttestBF(x = sleep$extra[sleep$group==1][1:i], y = sleep$extra[sleep$group==2][1:i], paired=TRUE)#
#' 	BF <- c(BF, as.vector(BF0))#
#' }#
#' #
#' BFplot(5:10, BF)#
#' }#
seqBF <- function(BFobject, min.n=10, step=1, ...) {#
#
	# For testing purposes ...#
	# BFobject <- ttest.1#
	# BFobject <- ttest.2#
	# BFobject <- ttest.2b#
	# BFobject <- ttest.p#
	# BFobject <- anova1#
	# BFobject <- lmBF1#
	dat <- BFobject@data#
	formula <- BFobject@numerator[[1]]@identifier$formula#
	BFtype <- class(BFobject@numerator[[1]])#
	print(BFtype)#
	FUN <- NULL#
	extra.args <- NULL#
	n.max <- NULL#
	switch(BFtype,#
		BFoneSample = {#
			FUN = ttestBF#
			max.n = nrow(dat)#
			extra.args = list(#
				paired = FALSE, #
				rscale = BFobject@numerator[[1]]@prior$rscale, #
				mu = BFobject@numerator[[1]]@prior$mu)#
		},#
		BFindepSample = {#
			FUN = ttestBF#
			counts = dat %>% count(group)#
			max.n = max(counts$n)#
			extra.args = list(#
				paired = FALSE, #
				rscale = BFobject@numerator[[1]]@prior$rscale)#
		}#
		# extra.args$progress <- FALSE #
	)#
	# override original parameters with the ... argument:#
	user.args <- list(...)#
	for (a in names(user.args)) {#
		extra.args[[a]] <- user.args[[a]]#
	}#
	if (is.null(FUN)) stop(paste0("BayesFactor object of type '", BFtype, "' not recognized (yet)."))#
	# at which n's should the BF be calculated?#
	ns <- seq(min.n, max.n, by=step)#
	if (tail(ns, 1) != max.n) ns <- c(ns, max.n)#
#
	pb <- txtProgressBar(min = 0, max = length(ns), style=3)#
	resSeq <- data.frame()#
	# TODO: Sample within each experimental group#
	for (i in 1:length(ns)) {#
		switch(BFtype,#
			BFoneSample = {extra.args$x <- dat[1:ns[i], ]},#
			BFindepSample = {#
				extra.args$formula <- as.formula(formula)				#
				# sample min.n from each group#
				extra.args$data <- dat %>% group_by(group) %>% slice(1:ns[i]) %>% ungroup() %>% as.data.frame()#
			}#
		)#
		res1 <- do.call(FUN, extra.args, envir = parent.frame())	#
		resSeq <- rbind(resSeq, data.frame(#
			n  = ns[i], #
			bf = res1@bayesFactor$bf,#
			error = res1@bayesFactor$error#
		))#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
	# define a new S4 class:#
	setClass("BFBayesFactorSeq", slots = c(bayesFactorSeq="data.frame"), contains = "BFBayesFactor")#
#
	RES <- new("BFBayesFactorSeq")#
	# copy all existing slots into new object.#
	# FIXME: Can this be done more efficiently?#
	for (s in names(getSlots("BFBayesFactor"))) {#
		slot(RES, s) <- slot(BFobject, s)#
	}#
#
	# add new sequential slot to results object#
	RES@bayesFactorSeq <- resSeq#
	return(RES)#
}#
#' @export#
plot.BFBayesFactorSeq <- function(x, ...) {#
	seqBFplot(n = x@bayesFactorSeq$n, bf = x@bayesFactorSeq$bf, log.it=FALSE, ...)#
}#
BF1 <- ttestBF(x = sleep$extra[sleep$group==1], y = sleep$extra[sleep$group==2], paired=TRUE)#
sBF1 <- seqBF(BF1, min.n=5)#
plot(sBF1)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras')
ttest.2c.seq <- seqBF(ttest.2, rscale=1)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras')
plot(ttest.2c.seq)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras')
plot(ttest.2b.seq)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras')
ttest.2c.seq
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras')
ttest.2b.seq
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras')
ttest.2.seq
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
#' Plot a sequence of Bayes factors#
#' #
#' This function creates a lineplot of a sequence of log Bayes factors. As a default, the function expects raw Bayes factors (i.e., non-logged Bayes factors). #
#' If you provide Bayes factors that are already logged (e.g., from the output of the ttest.tstat function), set \code{log.it} to \code{FALSE}.#
#' This function is in particular useful for plotting the trajectory of a sequential Bayes factor test#
#' @title Plot a Bayes factor object#
#' @param ... Parameters for the BayesFactor function defined in \code{FUN}. ALL parameters must be named.#
#' @param FUN String of the function of the BayesFactor package that should be applied, either "ttestBF", "lmBF", or "anovaBF"#
#' @param min.n Smallest number of participants for which the first BF should be computed. In a one-sample t test / paired t test, this is the overall sample size. In two-sample t tests and ANOVAs, this is the minimum size for each group.#
#' @param step Step size with which the number of participants is increased#
#' @author Felix Schönbrodt#
#
#' @export#
#' @import BayesFactor#
#' @importFrom dplyr#
#
#' @examples#
#' \dontrun{#
#' ## Sleep data from t test example#
#' data(sleep)#
#' #
#' # Compute accumulating evidence from n1=5 participants to n2=10 participants#
#' BF <- c()#
#' for (i in 5:10) {#
#' 	BF0 <- ttestBF(x = sleep$extra[sleep$group==1][1:i], y = sleep$extra[sleep$group==2][1:i], paired=TRUE)#
#' 	BF <- c(BF, as.vector(BF0))#
#' }#
#' #
#' BFplot(5:10, BF)#
#' }#
seqBF <- function(BFobject, min.n=10, step=1, ...) {#
#
	# For testing purposes ...#
	# BFobject <- ttest.1#
	# BFobject <- ttest.2#
	# BFobject <- ttest.2b#
	# BFobject <- ttest.p#
	# BFobject <- anova1#
	# BFobject <- lmBF1#
	dat <- BFobject@data#
	formula <- BFobject@numerator[[1]]@identifier$formula#
	BFtype <- class(BFobject@numerator[[1]])#
	print(BFtype)#
	FUN <- NULL#
	extra.args <- NULL#
	n.max <- NULL#
	switch(BFtype,#
		BFoneSample = {#
			FUN = ttestBF#
			max.n = nrow(dat)#
			extra.args = list(#
				paired = FALSE, #
				rscale = BFobject@numerator[[1]]@prior$rscale, #
				mu = BFobject@numerator[[1]]@prior$mu)#
		},#
		BFindepSample = {#
			FUN = ttestBF#
			counts = dat %>% count(group)#
			max.n = max(counts$n)#
			extra.args = list(#
				paired = FALSE, #
				rscale = BFobject@numerator[[1]]@prior$rscale)#
		}#
		# extra.args$progress <- FALSE #
	)#
	# override original parameters with the ... argument:#
	user.args <- list(...)#
	for (a in names(user.args)) {#
		print(a)#
		extra.args[[a]] <- user.args[[a]]#
	}#
	if (is.null(FUN)) stop(paste0("BayesFactor object of type '", BFtype, "' not recognized (yet)."))#
	# at which n's should the BF be calculated?#
	ns <- seq(min.n, max.n, by=step)#
	if (tail(ns, 1) != max.n) ns <- c(ns, max.n)#
#
	pb <- txtProgressBar(min = 0, max = length(ns), style=3)#
	resSeq <- data.frame()#
	# TODO: Sample within each experimental group#
	for (i in 1:length(ns)) {#
		switch(BFtype,#
			BFoneSample = {extra.args$x <- dat[1:ns[i], ]},#
			BFindepSample = {#
				extra.args$formula <- as.formula(formula)				#
				# sample min.n from each group#
				extra.args$data <- dat %>% group_by(group) %>% slice(1:ns[i]) %>% ungroup() %>% as.data.frame()#
			}#
		)#
		res1 <- do.call(FUN, extra.args, envir = parent.frame())	#
		resSeq <- rbind(resSeq, data.frame(#
			n  = ns[i], #
			bf = res1@bayesFactor$bf,#
			error = res1@bayesFactor$error#
		))#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
	# define a new S4 class:#
	setClass("BFBayesFactorSeq", slots = c(bayesFactorSeq="data.frame"), contains = "BFBayesFactor")#
#
	RES <- new("BFBayesFactorSeq")#
	# copy all existing slots into new object.#
	# FIXME: Can this be done more efficiently?#
	for (s in names(getSlots("BFBayesFactor"))) {#
		slot(RES, s) <- slot(BFobject, s)#
	}#
#
	# add new sequential slot to results object#
	RES@bayesFactorSeq <- resSeq#
	return(RES)#
}#
#' @export#
plot.BFBayesFactorSeq <- function(x, ...) {#
	seqBFplot(n = x@bayesFactorSeq$n, bf = x@bayesFactorSeq$bf, log.it=FALSE, ...)#
}#
BF1 <- ttestBF(x = sleep$extra[sleep$group==1], y = sleep$extra[sleep$group==2], paired=TRUE)#
sBF1 <- seqBF(BF1, min.n=5)#
plot(sBF1)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras')
ttest.2c.seq <- seqBF(ttest.2, rscale=1)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
#' Plot a sequence of Bayes factors#
#' #
#' This function creates a lineplot of a sequence of log Bayes factors. As a default, the function expects raw Bayes factors (i.e., non-logged Bayes factors). #
#' If you provide Bayes factors that are already logged (e.g., from the output of the ttest.tstat function), set \code{log.it} to \code{FALSE}.#
#' This function is in particular useful for plotting the trajectory of a sequential Bayes factor test#
#' @title Plot a Bayes factor object#
#' @param ... Parameters for the BayesFactor function defined in \code{FUN}. ALL parameters must be named.#
#' @param FUN String of the function of the BayesFactor package that should be applied, either "ttestBF", "lmBF", or "anovaBF"#
#' @param min.n Smallest number of participants for which the first BF should be computed. In a one-sample t test / paired t test, this is the overall sample size. In two-sample t tests and ANOVAs, this is the minimum size for each group.#
#' @param step Step size with which the number of participants is increased#
#' @author Felix Schönbrodt#
#
#' @export#
#' @import BayesFactor#
#' @importFrom dplyr#
#
#' @examples#
#' \dontrun{#
#' ## Sleep data from t test example#
#' data(sleep)#
#' #
#' # Compute accumulating evidence from n1=5 participants to n2=10 participants#
#' BF <- c()#
#' for (i in 5:10) {#
#' 	BF0 <- ttestBF(x = sleep$extra[sleep$group==1][1:i], y = sleep$extra[sleep$group==2][1:i], paired=TRUE)#
#' 	BF <- c(BF, as.vector(BF0))#
#' }#
#' #
#' BFplot(5:10, BF)#
#' }#
seqBF <- function(BFobject, min.n=10, step=1, ...) {#
#
	# For testing purposes ...#
	# BFobject <- ttest.1#
	# BFobject <- ttest.2#
	# BFobject <- ttest.2b#
	# BFobject <- ttest.p#
	# BFobject <- anova1#
	# BFobject <- lmBF1#
	dat <- BFobject@data#
	formula <- BFobject@numerator[[1]]@identifier$formula#
	BFtype <- class(BFobject@numerator[[1]])#
	print(BFtype)#
	FUN <- NULL#
	extra.args <- NULL#
	n.max <- NULL#
	switch(BFtype,#
		BFoneSample = {#
			FUN = ttestBF#
			max.n = nrow(dat)#
			extra.args = list(#
				paired = FALSE, #
				rscale = BFobject@numerator[[1]]@prior$rscale, #
				mu = BFobject@numerator[[1]]@prior$mu)#
		},#
		BFindepSample = {#
			FUN = ttestBF#
			counts = dat %>% count(group)#
			max.n = max(counts$n)#
			extra.args = list(#
				paired = FALSE, #
				rscale = BFobject@numerator[[1]]@prior$rscale)#
		}#
		# extra.args$progress <- FALSE #
	)#
	# override original parameters with the ... argument:#
	user.args <- list(...)#
	print(user.args)#
	for (a in names(user.args)) {#
		print(a)#
		extra.args[[a]] <- user.args[[a]]#
	}#
	if (is.null(FUN)) stop(paste0("BayesFactor object of type '", BFtype, "' not recognized (yet)."))#
	# at which n's should the BF be calculated?#
	ns <- seq(min.n, max.n, by=step)#
	if (tail(ns, 1) != max.n) ns <- c(ns, max.n)#
#
	pb <- txtProgressBar(min = 0, max = length(ns), style=3)#
	resSeq <- data.frame()#
	# TODO: Sample within each experimental group#
	for (i in 1:length(ns)) {#
		switch(BFtype,#
			BFoneSample = {extra.args$x <- dat[1:ns[i], ]},#
			BFindepSample = {#
				extra.args$formula <- as.formula(formula)				#
				# sample min.n from each group#
				extra.args$data <- dat %>% group_by(group) %>% slice(1:ns[i]) %>% ungroup() %>% as.data.frame()#
			}#
		)#
		res1 <- do.call(FUN, extra.args, envir = parent.frame())	#
		resSeq <- rbind(resSeq, data.frame(#
			n  = ns[i], #
			bf = res1@bayesFactor$bf,#
			error = res1@bayesFactor$error#
		))#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
	# define a new S4 class:#
	setClass("BFBayesFactorSeq", slots = c(bayesFactorSeq="data.frame"), contains = "BFBayesFactor")#
#
	RES <- new("BFBayesFactorSeq")#
	# copy all existing slots into new object.#
	# FIXME: Can this be done more efficiently?#
	for (s in names(getSlots("BFBayesFactor"))) {#
		slot(RES, s) <- slot(BFobject, s)#
	}#
#
	# add new sequential slot to results object#
	RES@bayesFactorSeq <- resSeq#
	return(RES)#
}#
#' @export#
plot.BFBayesFactorSeq <- function(x, ...) {#
	seqBFplot(n = x@bayesFactorSeq$n, bf = x@bayesFactorSeq$bf, log.it=FALSE, ...)#
}#
BF1 <- ttestBF(x = sleep$extra[sleep$group==1], y = sleep$extra[sleep$group==2], paired=TRUE)#
sBF1 <- seqBF(BF1, min.n=5)#
plot(sBF1)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras')
ttest.2c.seq <- seqBF(ttest.2, rscale=1)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
#' Plot a sequence of Bayes factors#
#' #
#' This function creates a lineplot of a sequence of log Bayes factors. As a default, the function expects raw Bayes factors (i.e., non-logged Bayes factors). #
#' If you provide Bayes factors that are already logged (e.g., from the output of the ttest.tstat function), set \code{log.it} to \code{FALSE}.#
#' This function is in particular useful for plotting the trajectory of a sequential Bayes factor test#
#' @title Plot a Bayes factor object#
#' @param ... Parameters for the BayesFactor function defined in \code{FUN}. ALL parameters must be named.#
#' @param FUN String of the function of the BayesFactor package that should be applied, either "ttestBF", "lmBF", or "anovaBF"#
#' @param min.n Smallest number of participants for which the first BF should be computed. In a one-sample t test / paired t test, this is the overall sample size. In two-sample t tests and ANOVAs, this is the minimum size for each group.#
#' @param step Step size with which the number of participants is increased#
#' @author Felix Schönbrodt#
#
#' @export#
#' @import BayesFactor#
#' @importFrom dplyr#
#
#' @examples#
#' \dontrun{#
#' ## Sleep data from t test example#
#' data(sleep)#
#' #
#' # Compute accumulating evidence from n1=5 participants to n2=10 participants#
#' BF <- c()#
#' for (i in 5:10) {#
#' 	BF0 <- ttestBF(x = sleep$extra[sleep$group==1][1:i], y = sleep$extra[sleep$group==2][1:i], paired=TRUE)#
#' 	BF <- c(BF, as.vector(BF0))#
#' }#
#' #
#' BFplot(5:10, BF)#
#' }#
seqBF <- function(BFobject, min.n=10, step=1, ...) {#
#
	# For testing purposes ...#
	# BFobject <- ttest.1#
	# BFobject <- ttest.2#
	# BFobject <- ttest.2b#
	# BFobject <- ttest.p#
	# BFobject <- anova1#
	# BFobject <- lmBF1#
	dat <- BFobject@data#
	formula <- BFobject@numerator[[1]]@identifier$formula#
	BFtype <- class(BFobject@numerator[[1]])#
	print(BFtype)#
	FUN <- NULL#
	extra.args <- NULL#
	n.max <- NULL#
	switch(BFtype,#
		BFoneSample = {#
			FUN = ttestBF#
			max.n = nrow(dat)#
			extra.args = list(#
				paired = FALSE, #
				rscale = BFobject@numerator[[1]]@prior$rscale, #
				mu = BFobject@numerator[[1]]@prior$mu)#
		},#
		BFindepSample = {#
			FUN = ttestBF#
			counts = dat %>% count(group)#
			max.n = max(counts$n)#
			extra.args = list(#
				paired = FALSE, #
				rscale = BFobject@numerator[[1]]@prior$rscale)#
		}#
		# extra.args$progress <- FALSE #
	)#
	# override original parameters with the ... argument:#
	user.args <- list(...)#
	print(user.args)#
	for (a in names(user.args)) {#
		print(a)#
		extra.args[[a]] <- user.args[[a]]#
	}#
	if (is.null(FUN)) stop(paste0("BayesFactor object of type '", BFtype, "' not recognized (yet)."))#
	# at which n's should the BF be calculated?#
	ns <- seq(min.n, max.n, by=step)#
	if (tail(ns, 1) != max.n) ns <- c(ns, max.n)#
#
	pb <- txtProgressBar(min = 0, max = length(ns), style=3)#
	resSeq <- data.frame()#
	# TODO: Sample within each experimental group#
	for (i in 1:length(ns)) {#
		switch(BFtype,#
			BFoneSample = {extra.args$x <- dat[1:ns[i], ]},#
			BFindepSample = {#
				extra.args$formula <- as.formula(formula)				#
				# sample min.n from each group#
				extra.args$data <- dat %>% group_by(group) %>% slice(1:ns[i]) %>% ungroup() %>% as.data.frame()#
			}#
		)#
		res1 <- do.call(FUN, extra.args, envir = parent.frame())	#
		resSeq <- rbind(resSeq, data.frame(#
			n  = ns[i], #
			bf = res1@bayesFactor$bf,#
			error = res1@bayesFactor$error#
		))#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
	# define a new S4 class:#
	setClass("BFBayesFactorSeq", slots = c(bayesFactorSeq="data.frame"), contains = "BFBayesFactor")#
#
	RES <- new("BFBayesFactorSeq")#
	# copy all existing slots into new object.#
	# FIXME: Can this be done more efficiently?#
	for (s in names(getSlots("BFBayesFactor"))) {#
		slot(RES, s) <- slot(BFobject, s)#
	}#
#
	# add new sequential slot to results object#
	RES@bayesFactorSeq <- resSeq#
	return(RES)#
}#
#' @export#
plot.BFBayesFactorSeq <- function(x, ...) {#
	seqBFplot(n = x@bayesFactorSeq$n, bf = x@bayesFactorSeq$bf, log.it=FALSE, ...)#
}#
BF1 <- ttestBF(x = sleep$extra[sleep$group==1], y = sleep$extra[sleep$group==2], paired=TRUE)#
sBF1 <- seqBF(BF1, min.n=5)#
plot(sBF1)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras')
seqBF(ttest.2, rscale=1)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
#' Plot a sequence of Bayes factors#
#' #
#' This function creates a lineplot of a sequence of log Bayes factors. As a default, the function expects raw Bayes factors (i.e., non-logged Bayes factors). #
#' If you provide Bayes factors that are already logged (e.g., from the output of the ttest.tstat function), set \code{log.it} to \code{FALSE}.#
#' This function is in particular useful for plotting the trajectory of a sequential Bayes factor test#
#' @title Plot a Bayes factor object#
#' @param ... Parameters for the BayesFactor function defined in \code{FUN}. ALL parameters must be named.#
#' @param FUN String of the function of the BayesFactor package that should be applied, either "ttestBF", "lmBF", or "anovaBF"#
#' @param min.n Smallest number of participants for which the first BF should be computed. In a one-sample t test / paired t test, this is the overall sample size. In two-sample t tests and ANOVAs, this is the minimum size for each group.#
#' @param step Step size with which the number of participants is increased#
#' @author Felix Schönbrodt#
#
#' @export#
#' @import BayesFactor#
#' @importFrom dplyr#
#
#' @examples#
#' \dontrun{#
#' ## Sleep data from t test example#
#' data(sleep)#
#' #
#' # Compute accumulating evidence from n1=5 participants to n2=10 participants#
#' BF <- c()#
#' for (i in 5:10) {#
#' 	BF0 <- ttestBF(x = sleep$extra[sleep$group==1][1:i], y = sleep$extra[sleep$group==2][1:i], paired=TRUE)#
#' 	BF <- c(BF, as.vector(BF0))#
#' }#
#' #
#' BFplot(5:10, BF)#
#' }#
seqBF <- function(BFobject, min.n=10, step=1, ...) {#
	user.args <- list(...)#
	print(user.args)#
	# For testing purposes ...#
	# BFobject <- ttest.1#
	# BFobject <- ttest.2#
	# BFobject <- ttest.2b#
	# BFobject <- ttest.p#
	# BFobject <- anova1#
	# BFobject <- lmBF1#
	dat <- BFobject@data#
	formula <- BFobject@numerator[[1]]@identifier$formula#
	BFtype <- class(BFobject@numerator[[1]])#
	print(BFtype)#
	FUN <- NULL#
	extra.args <- NULL#
	n.max <- NULL#
	switch(BFtype,#
		BFoneSample = {#
			FUN = ttestBF#
			max.n = nrow(dat)#
			extra.args = list(#
				paired = FALSE, #
				rscale = BFobject@numerator[[1]]@prior$rscale, #
				mu = BFobject@numerator[[1]]@prior$mu)#
		},#
		BFindepSample = {#
			FUN = ttestBF#
			counts = dat %>% count(group)#
			max.n = max(counts$n)#
			extra.args = list(#
				paired = FALSE, #
				rscale = BFobject@numerator[[1]]@prior$rscale)#
		}#
		# extra.args$progress <- FALSE #
	)#
	# override original parameters with the ... argument:#
	for (a in names(user.args)) {#
		print(a)#
		extra.args[[a]] <- user.args[[a]]#
	}#
	if (is.null(FUN)) stop(paste0("BayesFactor object of type '", BFtype, "' not recognized (yet)."))#
	# at which n's should the BF be calculated?#
	ns <- seq(min.n, max.n, by=step)#
	if (tail(ns, 1) != max.n) ns <- c(ns, max.n)#
#
	pb <- txtProgressBar(min = 0, max = length(ns), style=3)#
	resSeq <- data.frame()#
	# TODO: Sample within each experimental group#
	for (i in 1:length(ns)) {#
		switch(BFtype,#
			BFoneSample = {extra.args$x <- dat[1:ns[i], ]},#
			BFindepSample = {#
				extra.args$formula <- as.formula(formula)				#
				# sample min.n from each group#
				extra.args$data <- dat %>% group_by(group) %>% slice(1:ns[i]) %>% ungroup() %>% as.data.frame()#
			}#
		)#
		res1 <- do.call(FUN, extra.args, envir = parent.frame())	#
		resSeq <- rbind(resSeq, data.frame(#
			n  = ns[i], #
			bf = res1@bayesFactor$bf,#
			error = res1@bayesFactor$error#
		))#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
	# define a new S4 class:#
	setClass("BFBayesFactorSeq", slots = c(bayesFactorSeq="data.frame"), contains = "BFBayesFactor")#
#
	RES <- new("BFBayesFactorSeq")#
	# copy all existing slots into new object.#
	# FIXME: Can this be done more efficiently?#
	for (s in names(getSlots("BFBayesFactor"))) {#
		slot(RES, s) <- slot(BFobject, s)#
	}#
#
	# add new sequential slot to results object#
	RES@bayesFactorSeq <- resSeq#
	return(RES)#
}#
#' @export#
plot.BFBayesFactorSeq <- function(x, ...) {#
	seqBFplot(n = x@bayesFactorSeq$n, bf = x@bayesFactorSeq$bf, log.it=FALSE, ...)#
}#
BF1 <- ttestBF(x = sleep$extra[sleep$group==1], y = sleep$extra[sleep$group==2], paired=TRUE)#
sBF1 <- seqBF(BF1, min.n=5)#
plot(sBF1)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras')
seqBF(ttest.2, rscale=1)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras')
seqBF(ttest.2, rscale=1, test=2, xxx="a")
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras/BayesFactorExtras/R')
#' Plot a sequence of Bayes factors#
#' #
#' This function creates a lineplot of a sequence of log Bayes factors. As a default, the function expects raw Bayes factors (i.e., non-logged Bayes factors). #
#' If you provide Bayes factors that are already logged (e.g., from the output of the ttest.tstat function), set \code{log.it} to \code{FALSE}.#
#' This function is in particular useful for plotting the trajectory of a sequential Bayes factor test#
#' @title Plot a Bayes factor object#
#' @param ... Parameters for the BayesFactor function defined in \code{FUN}. ALL parameters must be named.#
#' @param FUN String of the function of the BayesFactor package that should be applied, either "ttestBF", "lmBF", or "anovaBF"#
#' @param min.n Smallest number of participants for which the first BF should be computed. In a one-sample t test / paired t test, this is the overall sample size. In two-sample t tests and ANOVAs, this is the minimum size for each group.#
#' @param step Step size with which the number of participants is increased#
#' @author Felix Schönbrodt#
#
#' @export#
#' @import BayesFactor#
#' @importFrom dplyr#
#
#' @examples#
#' \dontrun{#
#' ## Sleep data from t test example#
#' data(sleep)#
#' #
#' # Compute accumulating evidence from n1=5 participants to n2=10 participants#
#' BF <- c()#
#' for (i in 5:10) {#
#' 	BF0 <- ttestBF(x = sleep$extra[sleep$group==1][1:i], y = sleep$extra[sleep$group==2][1:i], paired=TRUE)#
#' 	BF <- c(BF, as.vector(BF0))#
#' }#
#' #
#' BFplot(5:10, BF)#
#' }#
seqBF <- function(BFobject, min.n=10, step=1, ...) {#
	user.args <- list(...)#
	print(user.args)#
	print("ARGGG!!")#
	# For testing purposes ...#
	# BFobject <- ttest.1#
	# BFobject <- ttest.2#
	# BFobject <- ttest.2b#
	# BFobject <- ttest.p#
	# BFobject <- anova1#
	# BFobject <- lmBF1#
	dat <- BFobject@data#
	formula <- BFobject@numerator[[1]]@identifier$formula#
	BFtype <- class(BFobject@numerator[[1]])#
	print(BFtype)#
	FUN <- NULL#
	extra.args <- NULL#
	n.max <- NULL#
	switch(BFtype,#
		BFoneSample = {#
			FUN = ttestBF#
			max.n = nrow(dat)#
			extra.args = list(#
				paired = FALSE, #
				rscale = BFobject@numerator[[1]]@prior$rscale, #
				mu = BFobject@numerator[[1]]@prior$mu)#
		},#
		BFindepSample = {#
			FUN = ttestBF#
			counts = dat %>% count(group)#
			max.n = max(counts$n)#
			extra.args = list(#
				paired = FALSE, #
				rscale = BFobject@numerator[[1]]@prior$rscale)#
		}#
		# extra.args$progress <- FALSE #
	)#
	# override original parameters with the ... argument:#
	for (a in names(user.args)) {#
		print(a)#
		extra.args[[a]] <- user.args[[a]]#
	}#
	if (is.null(FUN)) stop(paste0("BayesFactor object of type '", BFtype, "' not recognized (yet)."))#
	# at which n's should the BF be calculated?#
	ns <- seq(min.n, max.n, by=step)#
	if (tail(ns, 1) != max.n) ns <- c(ns, max.n)#
#
	pb <- txtProgressBar(min = 0, max = length(ns), style=3)#
	resSeq <- data.frame()#
	# TODO: Sample within each experimental group#
	for (i in 1:length(ns)) {#
		switch(BFtype,#
			BFoneSample = {extra.args$x <- dat[1:ns[i], ]},#
			BFindepSample = {#
				extra.args$formula <- as.formula(formula)				#
				# sample min.n from each group#
				extra.args$data <- dat %>% group_by(group) %>% slice(1:ns[i]) %>% ungroup() %>% as.data.frame()#
			}#
		)#
		res1 <- do.call(FUN, extra.args, envir = parent.frame())	#
		resSeq <- rbind(resSeq, data.frame(#
			n  = ns[i], #
			bf = res1@bayesFactor$bf,#
			error = res1@bayesFactor$error#
		))#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
	# define a new S4 class:#
	setClass("BFBayesFactorSeq", slots = c(bayesFactorSeq="data.frame"), contains = "BFBayesFactor")#
#
	RES <- new("BFBayesFactorSeq")#
	# copy all existing slots into new object.#
	# FIXME: Can this be done more efficiently?#
	for (s in names(getSlots("BFBayesFactor"))) {#
		slot(RES, s) <- slot(BFobject, s)#
	}#
#
	# add new sequential slot to results object#
	RES@bayesFactorSeq <- resSeq#
	return(RES)#
}#
#' @export#
plot.BFBayesFactorSeq <- function(x, ...) {#
	seqBFplot(n = x@bayesFactorSeq$n, bf = x@bayesFactorSeq$bf, log.it=FALSE, ...)#
}#
# BF1 <- ttestBF(x = sleep$extra[sleep$group==1], y = sleep$extra[sleep$group==2], paired=TRUE)#
# sBF1 <- seqBF(BF1, min.n=5)#
# plot(sBF1)
setwd('/Users/Felix/Documents/R/Funktionen/GitHub/BayesFactorExtras')
seqBF(ttest.2, rscale=1, test=2, xxx="a")
seqBF
ls()
plot(ttest.1)
plot(anova1)
plot(lm1)
